import numpy as np
import xarray as xr
import dask.array as da
import dask_ndfilters
from xmitgcm import open_mdsdataset
import os,glob,sys
sys.path.append("/nobackup/amondal/Python/Hector_Python_Scripts")
import time as tm
import xgcm
import xmitgcm
import warnings
warnings.filterwarnings("ignore")
from datetime import datetime,timedelta
from llcmap_bi_split import LLCMap_bi_split
from face_connections import face_connections
from llcmap_nea_split import LLCMap_nea_split
from netCDF4 import Dataset
import pylab as plt

def MIT_xr_date_location(VAR, level, ffilter, fsize, y1,m1,d1,h1,M1, y2, m2,d2,h2,M2, lat1, lat2, latinc, lon1,lon2,loninc):
  print('Entering MIT_xr_date_location')
  ########################################################
  # Same as MIT_xr but date and location are parameters
  # in a future update, this will require some errorhandling, especially when
  # you share this!
  ########################################################
  date = np.arange(datetime(y1,m1,d1,h1,M1),datetime(y2,m2,d2,h2,M2),
                   timedelta(hours=1)).astype(datetime)
  # timedelta(hours=1) - pretty sure this means that there are 1 hour increments?
  t = date.shape
  print('date')

  ##################################
  # Output grid
  ##################################
  print('setting location')
  lat_out = np.arange(lat1, lat2, latinc)
  lon_out = np.arange(lon1, lon2, loninc)
  #lat_out = np.arange(-90,90+0.04,0.04)
  #lon_out = np.arange(-180,180,0.04)
  print('location')
  ##################################
  # MIT iterations
  ##################################

  iter0 = 0#120960
  delta_t=45 #45 second iterations 
  delta = 3600/delta_t # iters
  nfiles = t[0]
  all_iters = iter0 + delta*np.arange(nfiles)

  #### don't change this part
  diro = '/nobackupp11/dmenemen/DYAMOND/c1440_llc2160/mit_output/'+VAR+'/'
  ####
  print('Directory of files')
  print(diro)
  nx=2160
  GRIDDIR='/nobackupp2/estrobac/geos5/MITGRID/llc2160/'
  ####
  print('before mds')
  ds = open_mdsdataset(diro, grid_dir=GRIDDIR, iters=all_iters[0], 
                       geometry='llc', read_grid=True, 
                       default_dtype=np.dtype('>f4'),
                       delta_t=delta_t, ignore_unknown_vars=True, nx=nx)

  grid = xgcm.Grid(ds, periodic=False, face_connections=face_connections)
  print('grid xgcm.Grid')


  coords = ds.coords.to_dataset().reset_coords()
  msk=coords.hFacC.sel(k=0)
  msk=msk.where(msk>0,np.nan) 
  XC=coords.XC*msk
  YC=coords.YC*msk
  print('initialize mapping to GEOS grid')
  mapper = LLCMap_nea_split(YC.values, XC.values,lat_out,
                            lon_out,radius=10e3)


  ##################################
  # Creating folders
  ################################
  #make directory for the output

  ### change this part
  #prntout = '/nobackup/htorresg/air_sea/ocean-atmos/NCFILES/geosgcm_surf_tides_4km/'
  prntout = '/nobackup/amondal/NCData/20210629_TempHeterogeneity/'
  #####
  dirout=prntout+VAR+"_"+str(level)
  print('==== Folder to be created =======')
  print(dirout)
  if not os.path.exists(dirout):
      os.makedirs(dirout)

    
  #################################
  # MIT iterations
  ################################
  output=xr.DataArray(np.zeros((1,lat_out.shape[0],lon_out.shape[0])),
                      dims=("time","lat","lon"),
                      coords={'lat':lat_out,'lon':lon_out})
  output = output.rename(VAR)


  for i in range(0,(nfiles)):
    start = tm.time()
    print('open files')
    print(all_iters[i])

    ds = open_mdsdataset(diro, grid_dir='/nobackupp2/estrobac/geos5/MITGRID/llc2160/', iters=all_iters[i], geometry='llc', read_grid=True, default_dtype=np.dtype('>f4'), delta_t=delta_t, ignore_unknown_vars=True, nx=nx)
    

    if VAR == 'V':
      #### change this part
      dirou='/nobackupp11/dmenemen/DYAMOND/c1440_llc2160/mit_output/U/'
      ####
      dsu = open_mdsdataset(dirou,
                      grid_dir='/nobackupp2/estrobac/geos5/MITGRID/llc2160/',
                            iters=all_iters[i],geometry='llc',read_grid=True,
                            default_dtype=np.dtype('>f4'),delta_t=delta_t,
                            ignore_unknown_vars=True,nx=nx)
      ds1 = open_mdsdataset(GRIDDIR, iters=1, ignore_unknown_vars=True, geometry='llc', nx=nx)

      AngleCS=ds1['CS'];AngleSN=ds1['SN'];
      print('=== interp 2d ====')
      UV=grid.interp_2d_vector({'X': dsu['U'].isel(k=level), 'Y': ds['V'].isel(k=level)},boundary='fill')
      x=(UV['X']*AngleSN+UV['Y']*AngleCS)
      print('== done interp 2d ===')
      print('=== x interpolated  ==')
      print(x.shape)
    elif VAR == 'U':
      #### change this part
      dirov='/nobackupp11/dmenemen/DYAMOND/c1440_llc2160/mit_output/V/'
      ####
      dsv = open_mdsdataset(dirov,
                      grid_dir='/nobackupp2/estrobac/geos5/MITGRID/llc2160/',
                            iters=all_iters[i],geometry='llc',read_grid=True,
                            default_dtype=np.dtype('>f4'),delta_t=delta_t,
                            ignore_unknown_vars=True,nx=nx)
      ds1 = open_mdsdataset(GRIDDIR, iters=1, ignore_unknown_vars=True, geometry='llc', nx=nx) 
      AngleCS=ds1['CS'];AngleSN=ds1['SN'];
      print('=== interp 2d ====')
      UV=grid.interp_2d_vector({'X': ds['U'].isel(k=level), 'Y': dsv['V'].isel(k=level)},boundary='fill')
      x=(UV['X']*AngleCS-UV['Y']*AngleSN)
      print('== done interp 2d ===')
      print('=== x interpolated  ==')
      print(x)
     
    elif VAR == 'oceTAUX':
      ### change this part
      dirov='/nobackupp11/dmenemen/DYAMOND/c1440_llc2160/mit_output/oceTAUY/'
      ###
      dsv = open_mdsdataset(dirov,
                      grid_dir='/nobackupp2/estrobac/geos5/MITGRID/llc2160/',
                            iters=all_iters[i],geometry='llc',read_grid=True,
                            default_dtype=np.dtype('>f4'),delta_t=delta_t,
                            ignore_unknown_vars=True,nx=nx)
      AngleCS=dsv['CS'];AngleSN=dsv['SN'];
      print('=== interp 2d ====')
      UV=grid.interp_2d_vector({'X': ds['oceTAUX'], 'Y': dsv['oceTAUY']},boundary='fill')
      x=(UV['X']*AngleCS-UV['Y']*AngleSN)
      print('== done interp 2d ===')
      print('=== x interpolated  ==')
      print(np.nanmean(x))
    
    elif VAR == 'oceTAUY':
	###### change this part
      dirou='/nobackupp11/dmenemen/DYAMOND/c1440_llc2160/mit_output/oceTAUX/'
	##### 
      dsu = open_mdsdataset(dirou,
                      grid_dir='/nobackupp2/estrobac/geos5/MITGRID/llc2160/',
                            iters=all_iters[i],geometry='llc',read_grid=True,
                            default_dtype=np.dtype('>f4'),delta_t=delta_t,
                            ignore_unknown_vars=True,nx=nx)
      AngleCS=dsu['CS'];AngleSN=dsu['SN'];
      print('=== interp 2d ====')
      UV=grid.interp_2d_vector({'X': dsu['oceTAUX'], 'Y': ds['oceTAUY']},boundary='fill')
      x=(UV['X']*AngleSN+UV['Y']*AngleCS)
      print('== done interp 2d ===')
      print('=== x interpolated  ==')
      print(np.nanmean(x))
    elif VAR == 'W':
      x=grid.interp(ds['W'],'Z',to='center',boundary='fill').isel(k=level)
    elif VAR == 'Eta':
      x=ds[VAR]
    elif VAR == 'KPPhbl':
      x=ds[VAR]
    elif VAR == 'Theta':
      x=ds[VAR].isel(k=level)
    elif VAR == 'Salt':
      x=ds[VAR].isel(k=level)
    elif VAR == 'oceQnet':
      x=ds[VAR].isel(k=level)
    elif VAR == 'oceQsw':
      x=ds[VAR].isel(k=level)
    else:
      print('not yet implemented')


    ##################################################
    ##### Mapping X to new grid
    print('map field') 
    TMP=xr.DataArray(mapper(x.values))
    print('mapped')

    if ffilter==1:
      print('apply filter')
      output = TMP - dask_ndfilters.generic_filter(da.from_array(TMP, \
               chunks=[131,960]), \
               function=np.nanmean, \
               size=fsize, \
               mode='wrap', \
               origin=0).compute()
    else:
      output[0] = TMP
    
    del TMP


    ##################################
    # Write output
    ##################################

    print('save output')

    output.rename(VAR).to_netcdf(dirout+'/'+VAR+'_'+date[i].strftime("%Y%m%d%H")+'.nc')

    print('finished day %02d'%i)
    end = tm.time()
    print(end - start)

#################################################################################
#################################################################################
#################################################################################
#################################################################################
#################################################################################
#################################################################################
#################################################################################
#################################################################################
  

#create a Main function in future versions of this

if __name__ == "__main__":
    # execute only if run as a script
    print('as a script')
    from dask.distributed import Client
    #client = Client(memory_limit='20GB',n_workers = 5, threads_per_worker=1)
    client = Client(memory_limit='4GB',n_workers = 6, threads_per_worker=1)
    #client
    print('Hola, dask has been set up!!!')

    from scrip import MIT_xr_date_location
    print('Hector script has been loaded')

    ##############################################################################
    #set date range from data you want
    y1 = 2020
    y2 = 2020
    m1 = 1
    m2 = 1
    d1 = 1
    d2 = 10
    h1 = 0
    h2 = 23
    M1 = 0
    M2 = 59
    ##########################
    #set location of cell(s)
    lat1 = 30.8
    lat2 = 31.2
    latinc = 0.04
    lon1 = -69.2
    lon2 = -68.8
    loninc = 0.04
    ##############################################################################
    print('Date and location has been set')
    VAR='Salt' ##### <<<<<<<<<<< ============ Select
    #nlevels=1  #### <<<<<<<====== vertical levels
    ffilter=0 ## <<== don't move
    fsize=0   ## <<==== don't mode
    #MIT_xr_date_location(VAR,1,ffilter,fsize,y1,m1,d1,h1,M1,y2,m2,d2,h2,M2,lat1,lat2,latinc,lon1,lon2,loninc)
    for levels in range(1,31):
        MIT_xr_date_location(VAR,levels,ffilter,fsize,y1,m1,d1,h1,M1,y2,m2,d2,h2,M2,lat1,lat2,latinc,lon1,lon2,loninc)
        print('Completed with level' + str(index))
        print('#######################')
        print('#######################')

